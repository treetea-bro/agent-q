from dotenv import load_dotenv

load_dotenv()

import asyncio
import io
import json

import ollama
from icecream import ic
from PIL import Image
from transformers import AutoModelForCausalLM, AutoTokenizer

from agentq.core.skills.get_dom_with_content_type import get_dom_with_content_type
from agentq.core.web_driver.playwright import PlaywrightManager
from models import ClickVideoParams, FilterParams, SearchParams
from tools import TOOLS

playwright = PlaywrightManager()


async def wait_for_navigation(max_retries=3):
    try:
        for attempt in range(max_retries):
            playwright_manager = PlaywrightManager()
            page = await playwright_manager.get_current_page()
            await page.wait_for_load_state("domcontentloaded", timeout=30000)
            print(f"[DEBUG] Navigation successful on attempt {attempt + 1}")
            return
    except Exception as e:
        print(f"[DEBUG] Navigation error on attempt {attempt + 1}: {str(e)}")
    print(f"[DEBUG] Navigation failed after {max_retries} attempts")


async def get_current_dom() -> str:
    await wait_for_navigation()
    dom = await get_dom_with_content_type(content_type="all_fields")
    return "\n\nCurrent DOM: " + str(dom)


async def get_current_screenshot() -> bytes:
    await wait_for_navigation()
    page = await playwright.get_current_page()
    screenshot_bytes = await page.screenshot(full_page=True)

    # Resize to 896x896 using PIL
    img = Image.open(io.BytesIO(screenshot_bytes))
    img = img.resize((896, 896), Image.LANCZOS)

    # Convert back to bytes (JPEG format)
    img_byte_arr = io.BytesIO()
    img.save(img_byte_arr, format="JPEG")
    return img_byte_arr.getvalue()


# ==============================
# ğŸ§° YouTube Functions
# ==============================
async def search(params: SearchParams):
    print(f"ğŸ” Searching: {params.query}")
    page = await playwright.get_current_page()
    await page.wait_for_selector('input[name="search_query"]')
    await page.fill('input[name="search_query"]', params.query)
    await page.press('input[name="search_query"]', "Enter")
    await page.wait_for_selector("ytd-item-section-renderer", timeout=10000)


async def apply_youtube_filters(params: FilterParams, timeout: int = 10000):
    page = await playwright.get_current_page()
    await page.wait_for_selector("#filter-button button", timeout=timeout)
    await page.click("#filter-button button")
    await page.wait_for_selector("ytd-search-filter-group-renderer", timeout=timeout)

    for idx, f in enumerate(params.filters):
        filter_groups = await page.query_selector_all(
            "ytd-search-filter-group-renderer"
        )
        for group in filter_groups:
            name_el = await group.query_selector(
                "#filter-group-name yt-formatted-string"
            )
            name = (await name_el.inner_text()).strip() if name_el else ""
            if name.lower() == f.group_name.lower():
                options = await group.query_selector_all("ytd-search-filter-renderer")
                for opt in options:
                    label_el = await opt.query_selector("#label yt-formatted-string")
                    label = (await label_el.inner_text()).strip() if label_el else ""
                    if label.lower() == f.option_label.lower():
                        link = await opt.query_selector("a#endpoint")
                        if link:
                            href = await link.get_attribute("href")
                            print(
                                f"âœ… Applying filter: {f.group_name} â†’ {f.option_label}"
                            )
                            await page.goto(f"https://www.youtube.com{href}")
                            await page.wait_for_selector(
                                "ytd-item-section-renderer", timeout=timeout
                            )
                            if idx < len(params.filters) - 1:
                                await page.wait_for_selector(
                                    "#filter-button button", timeout=timeout
                                )
                                await page.click("#filter-button button")
                                await page.wait_for_selector(
                                    "ytd-search-filter-group-renderer", timeout=timeout
                                )
                            break
                break


async def click_video_by_title(params: ClickVideoParams, timeout: int = 10000):
    page = await playwright.get_current_page()
    await page.wait_for_selector("ytd-rich-item-renderer", timeout=timeout)
    items = await page.query_selector_all("ytd-rich-item-renderer")
    for item in items:
        title_span = await item.query_selector("h3 a span")
        if not title_span:
            continue
        text = (await title_span.inner_text()).strip()
        if text == params.title:
            link = await item.query_selector("h3 a")
            if link:
                await link.click()
                print(f"ğŸ¬ Clicked video: {params.title}")
                return True
    print(f"âŒ No matching video found: {params.title}")
    return False


# ==============================
# ğŸ”§ Load xLAM Model
# ==============================
model_name = "Salesforce/Llama-xLAM-2-8b-fc-r"
# model_name = "Salesforce/xLAM-2-1b-fc-r"
tokenizer = AutoTokenizer.from_pretrained(model_name)
model = AutoModelForCausalLM.from_pretrained(
    model_name, device_map="auto", dtype="auto"
)


# ==============================
# ğŸ“ Instruction
# ==============================
LLM_SYSTEM_PROMPT = """
Available filters:
- Upload date: Last hour, Today, This week, This month, This year
- Type: Video, Channel, Playlist, Movie
- Duration: Under 4 minutes, 4 - 20 minutes, Over 20 minutes
- Features: Live, 4K, HD, Subtitles/CC, Creative Commons, 360Â°, VR180, 3D, HDR
- Sort by: Relevance, Upload date, View count, Rating

You are an agent that automates YouTube interactions using tools. Analyze the current screenshot of the page to understand the context and decide which tool to call next. Respond with tool calls in JSON format.
"""


# ==============================
# âš¡ Function Calling Runner
# ==============================
async def run_with_xlam(user_input: str):
    await playwright.async_initialize()

    prompt = [
        {"role": "system", "content": LLM_SYSTEM_PROMPT + await get_current_dom()},
        {"role": "user", "content": user_input},
    ]

    # tokenizerì˜ chat template í™œìš©
    inputs = tokenizer.apply_chat_template(
        prompt,
        tools=TOOLS,
        add_generation_prompt=True,
        return_dict=True,
        return_tensors="pt",
    )

    input_ids_len = inputs["input_ids"].shape[-1]
    inputs = {k: v.to(model.device) for k, v in inputs.items()}

    outputs = model.generate(**inputs, max_new_tokens=1024)
    generated_tokens = outputs[:, input_ids_len:]
    generated_text = tokenizer.decode(generated_tokens[0], skip_special_tokens=True)

    ic(generated_text)

    # JSON function call ìˆœì°¨ ì‹¤í–‰
    try:
        func_calls = json.loads(generated_text)
        if isinstance(func_calls, list):
            for call in func_calls:
                fn_name = call.get("name")
                args = call.get("arguments", {})

                if fn_name == "search":
                    params = SearchParams(**args)
                    await search(params)
                elif fn_name == "apply_youtube_filters":
                    params = FilterParams(**args)
                    await apply_youtube_filters(params)
                elif fn_name == "click_video_by_title":
                    params = ClickVideoParams(**args)
                    await click_video_by_title(params)

    except Exception as error:
        ic(error)


# if __name__ == "__main__":
#     asyncio.run(
#         run_with_xlam(
#             "Search for PokÃ©mon AMV, apply 4K filter, then click the full battle video"
#         )
#     )


# Function Calling Runner with Llama4 (ê°œì„ : contentì—ì„œ ì§ì ‘ íŒŒì‹±, multi-step ë£¨í”„ ì¶”ê°€)
async def run_with_llama(user_input: str):
    await playwright.async_initialize()
    model_name = "llama4:latest"

    # ì´ˆê¸° ìŠ¤í¬ë¦°ìƒ·
    screenshot_bytes = await get_current_screenshot()
    messages = [
        {"role": "system", "content": LLM_SYSTEM_PROMPT},
        {"role": "user", "content": user_input, "images": [screenshot_bytes]},
    ]
    max_steps = 5  # ìµœëŒ€ ìŠ¤í… ì œí•œ (ë¬´í•œ ë£¨í”„ ë°©ì§€)

    for step in range(max_steps):
        # Ollama í˜¸ì¶œ
        response = await ollama.AsyncClient().chat(
            model=model_name,
            messages=messages,
            tools=TOOLS,
            options={"temperature": 0.5, "num_ctx": 8192},  # ì»¨í…ìŠ¤íŠ¸ ì¦ê°€
        )
        ic(response)

        # tool_callsê°€ ì—†ìœ¼ë©´ contentì—ì„œ JSON ì¶”ì¶œ (ë¡œê·¸ì²˜ëŸ¼ ì§ì ‘ íŒŒì‹±)
        tool_calls = []
        if "message" in response and "content" in response["message"]:
            content = response["message"]["content"]
            # ì—¬ëŸ¬ JSON ê°ì²´ ì¶”ì¶œ (ë¡œê·¸ì²˜ëŸ¼ <|...|> ê°™ì€ ë…¸ì´ì¦ˆ ì œê±°)
            clean_content = re.sub(r"<\|.*?\|\>", "", content).strip()
            json_matches = re.findall(r"\{.*?\}", clean_content, re.DOTALL)
            for json_str in json_matches:
                try:
                    tool_call = json.loads(json_str)
                    tool_calls.append(tool_call)
                except json.JSONDecodeError:
                    print(f"JSON parse error: {json_str}")

        if not tool_calls:
            print("No tool calls generated. Stopping.")
            break

        # Tool calls ì‹¤í–‰
        for call in tool_calls:
            if "type" in call and call["type"] == "function":
                fn_name = call.get("name")
                args = call.get("parameters", {})  # 'parameters'ë¡œ ë³€ê²½ (ë¡œê·¸ ê¸°ë°˜)

                if fn_name == "search":
                    params = SearchParams(**args)
                    await search(params)
                elif fn_name == "apply_youtube_filters":
                    # ë¡œê·¸ì—ì„œ 'group' -> 'group_name' ë§¤í•‘ (í˜¸í™˜ì„±)
                    for f in args.get("filters", []):
                        if "group" in f:
                            f["group_name"] = f.pop("group")
                        if "option" in f:
                            f["option_label"] = f.pop("option")
                    params = FilterParams(**args)
                    await apply_youtube_filters(params)
                elif fn_name == "click_video_by_title":
                    params = ClickVideoParams(**args)
                    await click_video_by_title(params)

        # ë‹¤ìŒ ìŠ¤í…ì„ ìœ„í•´ ìƒˆ ìŠ¤í¬ë¦°ìƒ·ê³¼ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸
        screenshot_bytes = await get_current_screenshot()
        messages.append(
            {"role": "assistant", "content": response["message"]["content"]}
        )
        messages.append(
            {
                "role": "user",
                "content": "Continue based on the new page state.",
                "images": [screenshot_bytes],
            }
        )

        # ì™„ë£Œ ì¡°ê±´ (ì˜ˆ: ë¹„ë””ì˜¤ í´ë¦­ í›„ ì¢…ë£Œ)
        if any("click_video_by_title" in call.get("name", "") for call in tool_calls):
            print("Video clicked. Task complete.")
            break


if __name__ == "__main__":
    load_dotenv()
    asyncio.run(
        run_with_llama(
            "Search for PokÃ©mon AMV, apply 4K filter, then click the full battle video"
        )
    )
